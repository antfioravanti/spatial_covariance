install.packages("stpp")
library(stpp)
lgcp1 <- rlgcp(npoints = 200, nx = 50, ny = 50, nt = 50, separable = FALSE,
+ model = "gneiting", param = c(1, 1, 1, 1, 1, 2), var.grf = 1, mean.grf = 0)
lgcp1 <- rlgcp(npoints = 200, nx = 50, ny = 50, nt = 50, separable = FALSE,
model = "gneiting", param = c(1, 1, 1, 1, 1, 2), var.grf = 1,
mean.grf = 0)
lgcp1
lgcp1 <- rlgcp(npoints = 200, nx = 50, ny = 50, nt = 50, separable = FALSE,
model = "gneiting", param = c(1, 1, 1, 1, 1, 2), var.grf = 1,
mean.grf = 0)
N <- lgcp1$Lambda[,,1]
for(j in 2:(dim(lgcp1$Lambda)[3])){N <- N + lgcp1$Lambda[, , j]}
image(N, col = grey((1000:1) / 1000))
box()
animation(lgcp1$xyt, cex = 0.8, runtime = 10, add = TRUE,
prevalent = "orange")
lgcp1 <- rlgcp(npoints = 200, nx = 50, ny = 50, nt = 50, separable = FALSE,
model = "gneiting", param = c(1, 1, 1, 1, 1, 2), var.grf = 1,
mean.grf = 0)
N <- lgcp1$Lambda[,,1]
for(j in 2:(dim(lgcp1$Lambda)[3])){N <- N + lgcp1$Lambda[, , j]}
image(N, col = grey((1000:1) / 1000))
box()
lgcp2 <- rlgcp(npoints = 200, nx = 50, ny = 50, nt = 50, separable = TRUE,
model = "exponential", param = c(1, 1, 1, 1, 1, 2), var.grf = 2,
mean.grf = -0.5 * 2)
N <- lgcp2$Lambda[, , 1]
for(j in 2:(dim(lgcp2$Lambda)[3])){N <- N + lgcp2$Lambda[, , j]}
image(N, col = grey((1000:1) / 1000)) ; box()
if (!require(CompRandFld)) install.packages("CompRandFld"); library(CompRandFld)
write('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', file = "~/.Renviron", append = TRUE)
Sys.which("make")
install.packages("jsonlite", type = "source")
12.48/47.32
700/2
350*6
700*2
300*6
300*12*30
300*6
22*0.6
22*0.6*4*4
22*(1-0.43)*4*4
23*(1-0.43)*4*4
15/0.6
15/(1-0.43)
23*1.19
27.37*4*4
27.37*4*4*12
25*4*4
400*12
400*12*0.6
load("C:/Users/fioravanti/OneDrive - tu-dortmund.de/Desktop/af/pipbib3/Codes/spatiotemporal_simulations/separable_nonseparable_covariances/STP_Sim1.R")
200000*0.2
200000*0.02
200000*0.03
400000*0.03
# LOOP SIMULATION FOR INCREASING GRID / SAMPLE SIZE
#alphas = seq(from = 0.5, to = 1.5, by = 0.25)
alpha = 1
lambdas = seq(from = 2, to = 10, by = 2)
#lambda = 5
beta = 0
# Taper parameters
type = "rectangular"
c = 1
#l = 5 # should increase with increasing grid size
bandwidths = seq(from = 1, to = 11, by = 2)
final_df = data.frame()
tic("Whole simulations loop")
options(scipen = 5) # some decimals, set to 999 for max decimals
#options(scipen = 0) # scientific display
if (!require(sp)) install.packages("sp"); library(sp)
if (!require(tidyr)) install.packages("tidyr"); library(tidyr)
if (!require(dplyr)) install.packages("dplyr"); library(dplyr)
if (!require(gstat)) install.packages("gstat"); library(gstat)
if (!require(MASS)) install.packages("MASS"); library(MASS)
if (!require(fields)) install.packages("fields"); library(fields)
if (!require(rstudioapi)) install.packages("rstudioapi"); library(rstudioapi)
if (!require(pracma)) install.packages("pracma"); library(pracma)
if (!require(parallel)) install.packages("parallel"); library(parallel)
if (!require(reshape2)) install.packages("reshape2"); library(reshape2)
if (!require(ncf)) install.packages("ncf"); library(ncf)
if (!require(openxlsx)) install.packages("openxlsx"); library(openxlsx)
#if (!require(here)) install.packages("here"); library(here)
# Set the working directory to where the current file is saved
setwd(file.path(dirname(rstudioapi::getActiveDocumentContext()$path),".."))
wd = file.path(dirname(rstudioapi::getActiveDocumentContext()$path))
source("R/utils.R") # General functions
source("R/covariance_funs.R") # Analytical covariances
source("R/estimators.R") # Estimators
source("R/plotting.R")  # Plotting functions
set.seed(42)
#alphas = seq(from = 0.5, to = 1.5, by = 0.25)
alpha = 1
lambdas = seq(from = 2, to = 10, by = 2)
#lambda = 5
beta = 0
# Taper parameters
type = "rectangular"
c = 1
#l = 5 # should increase with increasing grid size
bandwidths = seq(from = 1, to = 11, by = 2)
final_df = data.frame()
tic("Whole simulations loop")
for(lambda in lambdas){
tic("Time for lambdas")
cat("\nPARAMETER lambda: ", lambda, "\n")
for(l in bandwidths){
tic("Time for bandwidth")
cat("\nPARAMETER l: ", l, "\n") # change name of parameter accordingly
params = list(sigma,
alpha1 = alpha,
alpha2 = alpha,
lambda1 = lambda,
lambda2 = lambda,
beta = beta,
test_sep= F)
tic("Loop for different grid sizes")
Ns = c(50, 60)  # Grid sizes
# Initialize vectors and lists to store results
truecov_matrices = list()
cov_matrices = list()
taper_matrices = list()
taper_covariances = list()
spectral_norm = numeric(length(Ns))
spectral_norm_tap = numeric(length(Ns))
spectral_norm_sepkron = numeric(length(Ns))
# frob_norm = numeric(length(Ns))
# frob_norm_tap = numeric(length(Ns))
# Looping a simulation for each grid size
for (iter in 1:length(Ns)){
tic("Time for interation")
cat("\nLoop iteration Grid size:", Ns[iter], "\n")
grid_size = Ns[iter]
nvec = c(grid_size, grid_size)
g = length(nvec)
N = prod(nvec)
spatial_process = simulate_spatial_process(
covariance_function = ModifiedExponentialCovariance,
grid_size = grid_size,
params = params,
seed = 42)
# Spatial Process
X = spatial_process$X
# True Covariance
true_cov = spatial_process$covariance
# Computing M vector for correct lags
M_ij_matrix = compute_M_matrix(N)
# Compute all autocovariances at once using vectorized form
# Use sapply to map through each row of the m_ij matrix
C_ij_vector = sapply(1:nrow(M_ij_matrix),
function(idx) SpatialAutoCov(X, M_ij_matrix[idx, ]))
# Now reshape it back to a matrix form (filled by columns)
C_ij_matrix = matrix(C_ij_vector, nrow=N, ncol=N)
# Compute Autocovariance lag 0,0
C_00 = SpatialAutoCov(X, c(0,0))
# Compute regular GammaEst matrix normalized with C_00
GammaEst = C_ij_matrix / C_00
# Compute Taper vector
kappa_ij_vector = sapply(1:nrow(M_ij_matrix),
function(idx) flat_top_taper(M_ij_matrix[idx, ],
c=c, l=l, type = type))
# Compute taper matrix
kappa_ij_matrix = matrix(kappa_ij_vector, nrow=N, ncol=N)
# Compute Tapered Covariance Matrix
GammaEstTaper = kappa_ij_matrix * GammaEst
# Compute Separable Taper Estimator
SepResults= Tapered_Sep_Autocovariance_Kron(X, l=l, c=c, type=type)
GammaEstTaperSep = SepResults$KronTaperCov
# Compute the Spectral norm between true_cov and estimated GammaEst_2
truecov_matrices[iter] = true_cov
cov_matrices[iter] = GammaEst
taper_matrices[iter] = kappa_ij_matrix
taper_covariances[iter] = GammaEstTaper
spectral_norm[iter] = norm(true_cov - GammaEst, type = "2")
spectral_norm_tap[iter] = norm(true_cov - GammaEstTaper, type = "2")
spectral_norm_sepkron[iter] = norm(true_cov - GammaEstTaperSep, type = "2")
toc()
}
toc()
# Preparing data frame for Excel export
results_df = data.frame(
GridSize = Ns,
alpha = alpha,
lambda = lambda,
beta = beta,
type = type,
c = c,
l = l,
SpectralNorm = spectral_norm,
SpectralNormTaper = spectral_norm_tap,
SpectralNormSepTaper = spectral_norm_sepkron
)
final_df = rbind(final_df, results_df)
toc()
}
toc()
}
params = list(sigma,
alpha1 = alpha,
alpha2 = alpha,
lambda1 = lambda,
lambda2 = lambda,
beta = beta,
test_sep= F)
grid_size = 50
spatial_process = simulate_spatial_process(
covariance_function = ModifiedExponentialCovariance,
grid_size = grid_size,
params = params,
seed = 42)
n1 = 50 # Dimension 1 size
n2 = 50 # Dimension 2 size
nvec = c(n1, n2)
N = prod(nvec)
# Generate spatial locations/coordinates of integers
grid = expand.grid(t1 = 1:n1, t2 = 1:n2)
# Smoothness parameter:
#   high makes the spatial process smooth
#   low makes the spatial process rougher
alpha1 = 1
alpha2 = 1
# Range parameter:
#   high makes the covariance decay more slowly with distance
#   low makes the covariance decay more quickly and with distance
lambda1 = 5
lambda2 = 5
# Variance parameter:
#   controls the magnitude of the overall variance
sigma = 1
# Separability parameter:
#   0 separable
#   1 non-separable
beta = 1
res = ModifiedExponentialCovariance(grid,
sigma = sigma,
alpha1 = alpha1,
alpha2 = alpha2,
lambda1 = lambda1,
lambda2 = lambda2,
beta = beta,
test_sep = T)
res
Ns = c(50, 60)
iter = 1
grid_size = Ns[iter]
nvec = c(grid_size, grid_size)
g = length(nvec)
N = prod(nvec)
spatial_process = simulate_spatial_process(
covariance_function = ModifiedExponentialCovariance,
grid_size = grid_size,
params = params,
seed = 42)
sigma
Ns = c(10, 60)  # Grid sizes
grid_size = Ns[iter]
nvec = c(grid_size, grid_size)
g = length(nvec)
N = prod(nvec)
spatial_process = simulate_spatial_process(
covariance_function = ModifiedExponentialCovariance,
grid_size = grid_size,
params = params,
seed = 42)
source("R/utils.R") # General functions
source("R/covariance_funs.R") # Analytical covariances
source("R/estimators.R") # Estimators
source("R/plotting.R")  # Plotting functions
